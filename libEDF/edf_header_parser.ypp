%code requires {
#ifndef EDF_HEADER_PARSER_YPP
#define EDF_HEADER_PARSER_YPP

#include "libEDF.h"

int yyparse(EDF_File * edf_file);
extern void yyrestart(FILE * input_file);

#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  size_t bytesParsed;
} YYLTYPE;
# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif

# define YYLLOC_DEFAULT(Current, Rhs, N)\
    do\
      if (YYID (N))\
  {\
    (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;  \
    (Current).first_column = YYRHSLOC (Rhs, 1).first_column;\
    (Current).last_line    = YYRHSLOC (Rhs, N).last_line;   \
    (Current).last_column  = YYRHSLOC (Rhs, N).last_column; \
    (Current).bytesParsed  = YYRHSLOC (Rhs, N).bytesParsed; \
  }\
      else\
  {\
    (Current).first_line   = (Current).last_line            \
                           = YYRHSLOC (Rhs, 0).last_line;   \
    (Current).first_column = (Current).last_column          \
                           = YYRHSLOC (Rhs, 0).last_column; \
    (Current).bytesParsed  = YYRHSLOC (Rhs, 0).bytesParsed;\
  }\
    while (YYID (0))

#endif // EDF_HEADER_PARSER_YPP
}

%locations
%define api.pure
%defines
%error-verbose
%parse-param {EDF_File * edf_file}
%lex-param {EDF_File * edf_file}

%union {
  struct {
    const char * text;
    size_t len;
  } str;

  size_t num;

  enum EDF_DataType type;

  class EDF_IntField * intField;
  class EDF_FloatField * floatField;
  class EDF_StringField * stringField;
}

%token <str> INTEGER
%token <str> FLOAT
%token <str> ID

%token <num> DIM

%token DATA_TYPE T_F64 T_F32 T_U08 T_I08 T_U16 T_I16 T_U32 T_I32 T_U64 T_I64
%type <type> type
%type <str> array
%type <str> string_array

%code top {
#include "edf_header_parser.h"
#include <stdlib.h>
#include <stdio.h>

void yyerror (YYLTYPE *locp, EDF_File * edf_file, char const *);

/* Copy of the header generated by Flex
 */
extern int yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param, EDF_File * edf_file);
}

%%

header
      : /* empty file */
      | header line
      ;

line
      : DIM '=' INTEGER ';'
              { const string arg3 = string($3.text, $3.len);
                size_t numDims = edf_file->getData().dimensions.size();
                if (numDims < $1) {
                  edf_file->getData().dimensions.resize($1, 1);
                }
                edf_file->getData().dimensions[$1-1] = atoi(arg3.c_str()); }
      | DATA_TYPE '=' type ';'
              { edf_file->getData().dataType = $3;
                edf_file->getFields().intFields.push_back( "DataType", $3); }
      | ID '=' string_array ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().stringFields.push_back( arg1, arg3); }
      | ID '=' INTEGER ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().intFields.push_back( arg1, atoi(arg3.c_str()) ); }
      | ID '=' array ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().floatFields.push_back( arg1, atof(arg3.c_str()) ); }
      ;

string_array
      : string_array ID   { const string temp = string($1.text, $1.len) + " " + string($2.text, $2.len);
                            $$.text = temp.c_str(); $$.len = temp.size(); }
      | ID                { $$ = $1; }
      ;

array
      : array FLOAT { $$ = $1; /* XXX - Fluffy Array Handling */ }
      | FLOAT       { $$ = $1; }
      ;

type
      : T_F64 { $$ = EDF_FLOAT_64; }
      | T_F32 { $$ = EDF_FLOAT_32; }
      | T_U08 { $$ = EDF_INT_08_U; }
      | T_I08 { $$ = EDF_INT_08_S; }
      | T_U16 { $$ = EDF_INT_16_U; }
      | T_I16 { $$ = EDF_INT_16_S; }
      | T_U32 { $$ = EDF_INT_32_U; }
      | T_I32 { $$ = EDF_INT_32_S; }
      | T_U64 { $$ = EDF_INT_64_U; }
      | T_I64 { $$ = EDF_INT_64_S; }
      ;

%%

void
yyerror (YYLTYPE *locp, EDF_File * edf_file, char const *s)
{
  fprintf( stderr, "SYNTHAX ERROR: %s\n", s );
  fprintf( stderr, "   at line: %4d col: %4d (to line: %4d col: %4d)\n",
           locp->first_line, locp->first_column, locp->last_line, locp->last_column);
}
