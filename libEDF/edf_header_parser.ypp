%code requires {
#ifndef EDF_HEADER_PARSER_YPP
#define EDF_HEADER_PARSER_YPP

#include "libEDF.h"

int yyparse(EDF_File * edf_file);

#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  size_t bytesParsed;
} YYLTYPE;
# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif

# define YYLLOC_DEFAULT(Current, Rhs, N)\
    do\
      if (YYID (N))\
  {\
    (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;  \
    (Current).first_column = YYRHSLOC (Rhs, 1).first_column;\
    (Current).last_line    = YYRHSLOC (Rhs, N).last_line;   \
    (Current).last_column  = YYRHSLOC (Rhs, N).last_column; \
    (Current).bytesParsed  = YYRHSLOC (Rhs, N).bytesParsed; \
  }\
      else\
  {\
    (Current).first_line   = (Current).last_line            \
                           = YYRHSLOC (Rhs, 0).last_line;   \
    (Current).first_column = (Current).last_column          \
                           = YYRHSLOC (Rhs, 0).last_column; \
    (Current).bytesParsed  = YYRHSLOC (Rhs, 0).bytesParsed;\
  }\
    while (YYID (0))

#endif // EDF_HEADER_PARSER_YPP
}

%locations
%define api.pure
%defines
%error-verbose
%parse-param {EDF_File * edf_file}
%lex-param {EDF_File * edf_file}

%union {
  struct {
    const char * text;
    size_t len;
  } str;

  class EDF_IntField * intField;
  class EDF_FloatField * floatField;
  class EDF_StringField * stringField;
}

%token <str> INTEGER
%token <str> FLOAT
%token <str> ID

%code top {
#include "edf_header_parser.h"
#include <stdlib.h>
#include <stdio.h>

void yyerror (YYLTYPE *locp, EDF_File * edf_file, char const *);

/* Copy of the header generated by Flex
 */
extern int yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param, EDF_File * edf_file);
}

%%

header
      : /* empty file */
      | header line
      ;

line
      : ID '=' ID ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().stringFields.push_back( arg1, arg3); }
      | ID '=' INTEGER ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().intFields.push_back( arg1, atoi(arg3.c_str()) ); }
      | ID '=' FLOAT ';'
              { const string arg1 = string($1.text, $1.len);
                const string arg3 = string($3.text, $3.len);
                edf_file->getFields().floatFields.push_back( arg1, atof(arg3.c_str()) ); }
      ;


%%

void
yyerror (YYLTYPE *locp, EDF_File * edf_file, char const *s)
{
  fprintf( stderr, "SYNTHAX ERROR: %s\n", s );
  fprintf( stderr, "   at line: %4d col: %4d (to line: %4d col: %4d)\n",
           locp->first_line, locp->first_column, locp->last_line, locp->last_column);
}
